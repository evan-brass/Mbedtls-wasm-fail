# Compiling mbedtls to wasm32-wasi for use within Deno or NodeJS
The goal is for this library to be combined with the native Deno or NodeJS networking available in their std libraries.

MbedTLS has support for:
1. TLS Cookies: Cookies provide TCP style connection verification => they prevent denial of service.  Normally ICE would be provide this protection using username + passwords, but our servers only use passwords.  It's not a matter of having too many connections: we can just stop accepting new connections.  The problem is detecting spam connections: which is where TCP Cookies come in.  They increase the connection handshake by 1 roundtrip - similiar to a TCP handshake - which verifies that the original packet was not spoofed.
2. TLS Connection ID: Normally DTLS connections are identified by the 5-tuple (local IP address + local port + protocol (UDP/TCP) + remote port + remote IP address).  ICE adds the ability to migrate connections between 5-tuples (using a USE_CANDIDATE).  If we don't implement ICE, then we don't gain this benefit.  DTLS has a new alternative way of identifying connections: Connection IDs (CIDs).  This has would give us back the ability to migrate connections between 5-tuples.  This only works for DTLS, however, so this wouldn't work for WebRTC connections that use Audio/Video because I don't think there's any similiar system for SRTP/SRTCP.
3. Same Port Reconnection: A problem I encountered with WebRTC-rs's DTLS implementation is that it doesn't handle/recognize a new connection coming from the old IP+Port.  The old connection just eats/drops the packets.  I got around this by inspecting the DTLS packets and detecting when a new handshake is incoming (multiple DTLS Hello packets).  I kill the old connection and create a new one.  The problem with this is that it is again a Denial of Service opportunity.  The proper way to handle this would be to use TLS Cookies to verify that the new connection is real.  If it is real, then we can close the old connection and continue with the new one.  I think that MbedTLS handles this automatically - perhaps (if I'm understanding their feature flags correctly).
4. Keep Certificates: Ideally, we want to hold the remote peer's certificate after connection so that we can use the certificate to identify the peer.  The certificate should be unique per remote peer.  Most likely what we actually want is a hash of the certificate to turn the identity certificate into a fixed length identifier.  Chrome I believe has implemented APIs that give access to the raw certificate chain of the remote peer, but there's no API for accessing the raw certificate of your local RTCCertificate.  Probably the way to handle this is to establish a temporary connection with yourself and retreive your remote (local) certificate bytes.  Again this only works for Chrome and similiar browsers.  FF and Safari haven't implemented those APIs.  All they have access to is a hash of the certificates (which is what we want anyway).  I believe it will always be the sha-256 hash of the cert, but that could change down the line.  For now, I think we just have to trust that it will be the SHA-256 and use that as the peer identifier.
